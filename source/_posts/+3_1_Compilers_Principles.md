---
layout:     post
title:      "编译原理"
date:       2018-01-03
tags:
    - Code
    - Compilers_Principles
categories:
    - Reading
---

本文将总结编译原理课程的相关内容，并希望读者阅读以后能对程序的编译过程有一个系统的理解，对于每一步具体的过程，这里只做概述，如果需要更加详细的过程，建议阅读更多参考书籍。


## 前言
> 本文对应教材为
> 编译原理(英文版•第2版) Alfred V.Aho, Monica S.Lam, Ravi Sethi, Jeffrey D.Ullman，机械工业出版社



## 引论

+ 语言处理器：编译器 / 解释器
+ 编译器流程示例
  + 源程序->预处理器
  + 经过预处理的源程序->编译器
  + 目标汇编程序->汇编器
  + 可重定位机器代码->连接器/加载器
  + 目标机器代码
+ 一个编译器的结构
  + 字符流->词法分析器（变成词素序列
  + 符号流->语法分析（采用一定组织形式表示语法结构
  + 语法树->语义分析器（使用语法结构和符号表来检查是否符合语言定义中的语义（比如类型检查/自动类型转化等
  + 语法树->中间代码生成器（将语法结构翻译成中间表示形式，比如类似汇编语言的三地址代码
  + 中间表示形式->机器无关代码优化器（生成更好的中间表示形式代码
  + 中间表示形式->代码生成器（翻译成等价机器代码
  + 目标机器语言->机器相关语言代码优化器（生成更好的机器代码
  + 目标代码
+ 程序设计语言的发展历史

<!--more-->

## 一个简单的语法制导器
+ 语法描述了程序的正确形式，语义定义了程序的含义，及运行时在做什么
+ 一个上下文无关文法由以下四部分组成，终结符号/非终结符号/产生式集合/非终结符号为起始符
+ 语法分析是如何使用一个文法生成一个终结符号串的过程
+ 符号表是一种供编译器保存有关程序构造各种信息的数据结构
+ 静态检查包括语法检查，类型检查等

## 词法分析
+ 词法分析器的主要任务是读入程序的输入字符串，将他们组合成词素，生成并输出一个词法单元序列，每个词法单元对应一个词素
+ 词法单元的规约
  + 串和语言及其运算
  + 正则表达式及正则定义
  + 状态转移图
  + NFA与DFA，以及互相转化。

## 语法分析
+ 描述语言的模型之一：文法。
  + 使用字母表，串及其连接。
  + 0型文法/上下文相关/无关方法/正则文法。
  + 文法中规则的数目应该适中，消除二义性和不可达的。
  + 从文法推到出语言/从语言推到回文法。
  + 正则文法与状态机之间的互相转化。
+ 语法分析：
    + 自顶向下：LL/LL(k)
    + 自下向上:LR
    + 递归下降
      + 使用下推自动机（PDA）
      + 将上下文无关文法转化为PDA
    + LL(K)
      + 构造预测分析表
        + 对与每个A->a产生式子的a，计算FIRST(a) FELLOW(a)
        + 对于FIRST(a)中的每个α，将A->a加入M[A, α]，若α为空，且结束符（$）在FELLOW(a)中，将A->a加入到M[A, $]中。
      + 根据预测分析表选择产生式开始置换，并输出相应产生式。
    + 自下向上：LR/简单优先/符号优先
    + 简单优先
        + 文法的关系：自反/传递/对称，关系和/乘积，计算闭包。 
        + FIRST/LAST关系
        + `<` `=` `>`关系，优先表
        + 要求：产生式右边不能相同/任何两种简单符号只有一种关系（偏序）
        + 可以通过增加非终结符号的方法达到目的。
      + 算符优先
        + 速度空间的相对性
      + 优先函数，不固定，只要保证相对关系就可以了。
        + bell方法：有向图构造法
        + floyd方法：+1直到没有改变
    + LR语法分析
      + 动作：移入/规约/接受/报错
      + LR(0)表的构建：产生式，闭包，构建表。

## 语法制导

简单的来说就是为语法树上的每个节点分配一个动作。

## 中间代码生成

简单的来说就是生成指定格式的中间代码。

## 代码优化

+ 所谓优化，一般是指提高目标程序的质量，比如运行速度或者减少所占的储存空间。
+ 分类
  + 机器无关的优化/机器相关的优化
    + 常数合并，当场就给算出来。
    + 公共表达式的消除，不需要算两次。
    + 循环不变式的外提，循环内不改变提到循环外部。
    + 运算强度的削弱，乘法变加法。
  + 局部优化
    + 线性代码块的优化
    + 简单开销少，效果比较差。
  + 全局优化
    + 非线性程序块的优化，需要考虑较多因素。
    + 优化复杂，开销大，效果好。
+ 基本块的划分（期末会考）
  + 入口语句集合：第一个语句/goto语句的下一条语句/goto语句转到的语句。
  + 入口语句集合排序后每个入口语句到下一个入口语句号前一语句，最后一块为最后入口语句到最后语句。
  + 不在任何块中的语句，是不可达的语句，可以删除。
  + 机器无关/循环优化举例：比如变换终态控制条件。
+ 变量定义点
  + 确定方法：赋值语句左边/输入语句输入名表/标识符被赋新值。
  + 一段程序块内没有定义点：区域常量。
  + 循环内部的不变式，外提。
  + 循环内部的表达式是关于区域变量循环线性变化的，进行强度削弱。
  + 提出公共表达式：表达形式上完全相同，所有变量在两次中间无定义点。
  + 两个参数全是常数，就提前计算出结果。
+ 循环优化
  + 循环优化的巨大性能提升，尤其是内层循环。
  + 数组元素的地址计算多种优化方法
  + 循环的展开和合并方法
+ 借助DAG（无环有向图）进行优化
  + 子节点：变量，父节点：结果，通过运算符
  + 主要思路：描述比较直接，方便得到“合并已知量，删除无用赋值，删除多余运算。”以后的等价块。
+ 并线分支的优化
  + 彼此无关的程序变成并行分支
  + 两个基本块彼此独立，用图论的话来说彼此互相不抵达，他们就是可并行的。
+ 窥孔优化
  + 每次只查看所生成目标代码中相邻的几条指令，对它们进行优化。
  + 删除多余的存取指令/删除绝对不会执行的代码